---
## Author
author:
  name: Бондарь Татьяна Бладимировна
  degrees: none 
  orcid: 0000-0002-0877-7063
  email: 1132246711@rudn.ru
  affiliation:
    - name: Российский университет дружбы народов
      country: Российская Федерация
      postal-code: 117198
      city: Москва
      address: ул. Миклухо-Маклая, д. 6

## Title
title: "Дискреционное разграничение прав в Linux. Исследование влияния дополнительных атрибутов"
subtitle: "Основы информационной безопасности"
license: "CC BY"
---

# Цель работы

Изучение механизмов изменения идентификаторов, применения SetUID- и Sticky-битов. Получение практических навыков работы в консоли с дополнительными атрибутами. Рассмотрение работы механизма смены идентификатора процессов пользователей, а также влияние бита Sticky на запись и удаление файлов.

# Теоретическое введение

1. Дополнительные атрибуты файлов Linux

В Linux существует три основных вида прав — право на чтение (read), запись (write) и выполнение (execute), а также три категории пользователей, к которым они могут применяться — владелец файла (user), группа владельца (group) и все остальные (others). Но, кроме прав чтения, выполнения и записи, есть еще три дополнительных атрибута. 

**Sticky bit**

Используется в основном для каталогов, чтобы защитить в них файлы. В такой каталог может писать любой пользователь. Но, из такой директории пользователь может удалить только те файлы, владельцем которых он является. Примером может служить директория /tmp, в которой запись открыта для всех пользователей, но нежелательно удаление чужих файлов.

**SUID (Set User ID)**

Атрибут исполняемого файла, позволяющий запустить его с правами владельца. В Linux приложение запускается с правами пользователя, запустившего указанное приложение. Это обеспечивает дополнительную безопасность т.к. процесс с правами пользователя не сможет получить доступ к важным системным файлам, которые принадлежат пользователю root.

**SGID (Set Group ID)**

Аналогичен suid, но относиться к группе. Если установить sgid для каталога, то все файлы созданные в нем, при запуске будут принимать идентификатор группы каталога, а не группы владельца, который создал файл в этом каталоге.

**Обозначение атрибутов sticky, suid, sgid**

Специальные права используются довольно редко, поэтому при выводе программы ls -l символ, обозначающий указанные атрибуты, закрывает символ стандартных прав доступа.

Пример:
`rwsrwsrwt`

где первая s — это suid, вторая s — это sgid, а последняя t — это sticky bit

В приведенном примере не понятно, rwt — это rw- или rwx? Определить это просто. Если t маленькое, значит x установлен. Если T большое, значит x не установлен. То же самое правило распространяется и на s.

В числовом эквиваленте данные атрибуты определяются первым символом при четырехзначном обозначении (который часто опускается при назначении прав), например в правах 1777 — символ 1 обозначает sticky bit. 

2. Компилятор GCC

GСС - это свободно доступный оптимизирующий компилятор для языков C, C++. Собственно программа gcc это некоторая надстройка над группой компиляторов, которая способна анализировать имена файлов, передаваемые ей в качестве аргументов, и определять, какие действия необходимо выполнить. Файлы с расширением .cc или .C рассматриваются, как файлы на языке C++, файлы с расширением .c как программы на языке C, а файлы c расширением .o считаются объектными [@gcc].

# Выполнение лабораторной работы

Для лабораторной работы необходимо проверить, установлен ли компилятор gcc, комнда `gcc -v` позволяет это сделать. Также осуществляется отключение системы запретом с помощью `setenforce 0` (рис. 1).

Осуществляется вход от имени пользователя guest 

Создание файла simpleid.c и запись в файл кода.

![Создание файла](image/1.PNG){#fig:001 width=70%}

Cодержимое файла выглядит следующти образом (рис. 2)

![Содержимое файла](image/2.PNG){#fig:002 width=70%}

Компилирую файл, проверяю, что он скомпилировался (рис. 3)

![Компиляция файла](image/3.PNG){#fig:003 width=70%}

Запускаю исполняемый файл. В выводе файла выписаны номера пользоватея и групп, от вывода при вводе if, они отличаются только тем, что информации меньше 

Создание, запись в файл и компиляция файла simpleid2.c. Запуск программы (рис. 4)

![Создание и компиляция файла](image/5.PNG){#fig:005 width=70%}

![Содержимое файла](image/4.PNG){#fig:004 width=70%}

С помощью chown изменяю владельца файла на суперпользователя, с помощью chmod изменяю права доступа (рис. 6)

![Смена владельца файла и прав доступа к файлу](image/6.PNG){#fig:006 width=70%}

Сравнение вывода программы и команды id, наша команда снова вывела только ограниченное количество информации(рис. 7)

![Запуск файла](image/7.PNG){#fig:007 width=70%}

Создание и компиляция файла readfile.c (рис. 8)

![Содержимое файла](image/8.PNG){#fig:008 width=80%}

Снова от имени суперпользователи меняю владельца файла readfile. Далее меняю права доступа так, чтобы пользователь guest не смог прочесть содержимое файла (рис. 9)

![Смена владельца файла и прав доступа к файлу](image/9.PNG){#fig:009 width=80%}

Проверка прочесть файл от имени пользователя guest.Прочесть файл не удается (рис. 10)

![Попытка прочесть содержимое файла](image/10.PNG){#fig:010 width=80%}

Попытка прочесть тот же файл с помощью программы readfile, в ответ получаем "отказано в доступе" (рис. 11)

![Попытка прочесть содержимое файла программой](image/11.PNG){#fig:011 width=80%}

Попытка прочесть файл `\etc\shadow` с помощью программы, все еще получаем отказ в доступе (рис. 12)

![Попытка прочесть содержимое файла программой](image/12.PNG){#fig:012 width=80%}

Пробуем прочесть эти же файлы от имени суперпользователя и чтение файлов проходит успешно (рис. 13)

![Чтение файла от имени суперпользователя](image/13.PNG){#fig:013 width=80%}

Проверяем папку tmp на наличие атрибута Sticky, т.к. в выводе есть буква t, то атрибут установлен (рис. 14)

![Проверка атрибутов директории tmp](image/14.PNG){#fig:014 width=80%}

От имени пользователя guest создаю файл с текстом, добавляю права на чтение и запись для других пользователей (рис. 15)

![Создание файла, изменение прав доступа](image/15.PNG){#fig:015 width=80%}

Вхожу в систему от имени пользователя guest2, от его имени могу прочитать файл file01.txt, но перезаписать информацию в нем не могу. Также невозможно добавить в файл file01.txt новую информацию от имени пользователя guest2.  (рис. 16)

![Попытка чтения файла](image/16.PNG){#fig:016 width=80%}

От имени суперпользователя снимаем с директории атрибут Sticky (рис. 17)

![Смена атрибутов файла](image/17.PNG){#fig:017 width=80%}

Далее был выполнен повтор предыдущих действий. По результатам без Sticky-бита запись в файл и дозапись в файл осталась невозможной, зато удаление файла прошло успешно (рис. 18)

![Повтор предыдущих действий](image/18.PNG){#fig:018 width=80%}

Возвращение директории tmp атрибута t от имени суперпользователя (рис. 19)

![Изменение атрибутов](image/19.PNG){#fig:019 width=80%}

# Выводы

Изучила механизм изменения идентификаторов, применила
SetUID- и Sticky-биты. Получила практические навыки работы в консоли с дополнительными атрибутами. Рассмотрела работы механизма смены идентификатора процессов пользователей, а также влияние бита Sticky на запись и удаление файлов.

# Список литературы

[0] Методические материалы курса

[1] Права доступа: https://codechick.io/tutorials/unix-linux/unix-linux-permissions
